# Migration Guide: JSON to Normalized Schema

## Overview
This guide provides step-by-step instructions for migrating from the current JSON-based schema to the fully normalized 3NF-compliant schema with zero JSON fields.

## Migration Strategy

### Phase 1: Parallel Schema Deployment (Zero Downtime)
The normalized schema is created with `_normalized` suffixes to run alongside existing tables.

**Tables Created:**
- `course_syllabus_normalized` (replaces `course_syllabus`)
- `syllabus_modules_normalized` (replaces `syllabus_models`)
- `syllabus_titles_normalized` (replaces `syllabus_titles`)
- `syllabus_topics_normalized` (replaces `syllabus_topics`)
- `curriculum_logs_normalized` (replaces `curriculum_logs`)
- `department_overview_normalized` (replaces `department_overview`)

**New Normalized Tables:**
- `course_objectives`, `course_outcomes`, `course_textbooks`, `course_references`
- `course_prerequisites`, `teamwork_activities`
- `self_learning_main_topics`, `self_learning_resources`
- `co_po_mappings`, `co_pso_mappings`, `peo_po_mappings`
- `curriculum_log_changes`
- `department_peos`, `department_pos`, `department_psos`

### Phase 2: Data Migration Scripts

#### A. Migrate Course Objectives (JSON Array → Table)

```sql
-- Example: Migrate objectives from course_syllabus.objectives JSON to course_objectives table
INSERT INTO course_objectives (syllabus_id, objective_text, display_order)
SELECT 
    csn.id as syllabus_id,
    obj_value as objective_text,
    obj_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(cs.objectives, JSON_ARRAY()),
    '$[*]' COLUMNS(
        obj_index FOR ORDINALITY,
        obj_value TEXT PATH '$'
    )
) AS jt
WHERE cs.objectives IS NOT NULL AND JSON_LENGTH(cs.objectives) > 0;
```

#### B. Migrate Course Outcomes (JSON Array → Table)

```sql
INSERT INTO course_outcomes (syllabus_id, outcome_code, outcome_text, display_order)
SELECT 
    csn.id as syllabus_id,
    CONCAT('CO', out_index) as outcome_code,
    out_value as outcome_text,
    out_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(cs.outcomes, JSON_ARRAY()),
    '$[*]' COLUMNS(
        out_index FOR ORDINALITY,
        out_value TEXT PATH '$'
    )
) AS jt
WHERE cs.outcomes IS NOT NULL AND JSON_LENGTH(cs.outcomes) > 0;
```

#### C. Migrate Textbooks (JSON Array → Structured Table)

```sql
-- Textbooks stored as simple strings need parsing
-- Assuming format: "Title by Authors, Publisher, Edition, Year"
INSERT INTO course_textbooks (syllabus_id, title, authors, publisher, edition, year, display_order)
SELECT 
    csn.id as syllabus_id,
    SUBSTRING_INDEX(tb_value, ' by ', 1) as title,
    SUBSTRING_INDEX(SUBSTRING_INDEX(tb_value, ' by ', -1), ',', 1) as authors,
    NULL as publisher,
    NULL as edition,
    NULL as year,
    tb_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(cs.textbooks, JSON_ARRAY()),
    '$[*]' COLUMNS(
        tb_index FOR ORDINALITY,
        tb_value TEXT PATH '$'
    )
) AS jt
WHERE cs.textbooks IS NOT NULL AND JSON_LENGTH(cs.textbooks) > 0;

-- Note: Manual review recommended for proper author/publisher parsing
```

#### D. Migrate References (JSON Array → Structured Table)

```sql
INSERT INTO course_references (syllabus_id, title, authors, publisher, edition, year, url, display_order)
SELECT 
    csn.id as syllabus_id,
    SUBSTRING_INDEX(ref_value, ' by ', 1) as title,
    SUBSTRING_INDEX(SUBSTRING_INDEX(ref_value, ' by ', -1), ',', 1) as authors,
    NULL as publisher,
    NULL as edition,
    NULL as year,
    CASE 
        WHEN ref_value LIKE 'http%' THEN ref_value 
        ELSE NULL 
    END as url,
    ref_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(cs.reference_list, JSON_ARRAY()),
    '$[*]' COLUMNS(
        ref_index FOR ORDINALITY,
        ref_value TEXT PATH '$'
    )
) AS jt
WHERE cs.reference_list IS NOT NULL AND JSON_LENGTH(cs.reference_list) > 0;
```

#### E. Migrate Prerequisites (JSON Array → Foreign Key Table)

```sql
-- Prerequisites stored as course codes - need to resolve to course IDs
INSERT INTO course_prerequisites (syllabus_id, prerequisite_course_id, prerequisite_type)
SELECT 
    csn.id as syllabus_id,
    c.id as prerequisite_course_id,
    'Mandatory' as prerequisite_type
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(cs.prerequisites, JSON_ARRAY()),
    '$[*]' COLUMNS(
        prereq_code TEXT PATH '$'
    )
) AS jt
JOIN courses c ON c.course_code = jt.prereq_code
WHERE cs.prerequisites IS NOT NULL AND JSON_LENGTH(cs.prerequisites) > 0;
```

#### F. Migrate Teamwork (Nested JSON → Normalized Tables)

```sql
-- First, create syllabus entries with total hours
INSERT INTO course_syllabus_normalized (course_id, teamwork_total_hours, self_learning_total_hours)
SELECT 
    cs.course_id,
    COALESCE(JSON_EXTRACT(cs.teamwork, '$.hours'), 0) as teamwork_total_hours,
    COALESCE(JSON_EXTRACT(cs.selflearning, '$.hours'), 0) as self_learning_total_hours
FROM course_syllabus cs
ON DUPLICATE KEY UPDATE
    teamwork_total_hours = VALUES(teamwork_total_hours),
    self_learning_total_hours = VALUES(self_learning_total_hours);

-- Then, extract teamwork activities
INSERT INTO teamwork_activities (syllabus_id, activity_name, display_order)
SELECT 
    csn.id as syllabus_id,
    activity_value as activity_name,
    activity_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(JSON_EXTRACT(cs.teamwork, '$.activities'), JSON_ARRAY()),
    '$[*]' COLUMNS(
        activity_index FOR ORDINALITY,
        activity_value TEXT PATH '$'
    )
) AS jt
WHERE cs.teamwork IS NOT NULL;
```

#### G. Migrate Self-Learning (Deeply Nested JSON → Two-Level Tables)

```sql
-- Step 1: Extract main topics
INSERT INTO self_learning_main_topics (syllabus_id, main_topic, display_order)
SELECT 
    csn.id as syllabus_id,
    main_topic_text as main_topic,
    main_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
CROSS JOIN JSON_TABLE(
    COALESCE(JSON_EXTRACT(cs.selflearning, '$.main_inputs'), JSON_ARRAY()),
    '$[*]' COLUMNS(
        main_index FOR ORDINALITY,
        main_topic_text TEXT PATH '$.main',
        internal_resources JSON PATH '$.internal'
    )
) AS jt_main
WHERE cs.selflearning IS NOT NULL;

-- Step 2: Extract internal resources for each main topic
INSERT INTO self_learning_resources (main_topic_id, resource_text, resource_type, display_order)
SELECT 
    slmt.id as main_topic_id,
    internal_value as resource_text,
    CASE 
        WHEN internal_value LIKE 'http%' THEN 'Link'
        ELSE 'Text'
    END as resource_type,
    internal_index as display_order
FROM course_syllabus cs
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id
JOIN self_learning_main_topics slmt ON slmt.syllabus_id = csn.id
CROSS JOIN JSON_TABLE(
    COALESCE(JSON_EXTRACT(cs.selflearning, 
        CONCAT('$.main_inputs[', slmt.display_order - 1, '].internal')), 
        JSON_ARRAY()),
    '$[*]' COLUMNS(
        internal_index FOR ORDINALITY,
        internal_value TEXT PATH '$'
    )
) AS jt_internal
WHERE cs.selflearning IS NOT NULL;
```

#### H. Migrate Syllabus Modules (Relational → Enhanced Relational)

```sql
-- Migrate modules (already relational, but link to normalized syllabus)
INSERT INTO syllabus_modules_normalized (syllabus_id, module_name, module_number, display_order)
SELECT 
    csn.id as syllabus_id,
    sm.model_name as module_name,
    ROW_NUMBER() OVER (PARTITION BY sm.syllabus_id ORDER BY sm.position) as module_number,
    sm.position as display_order
FROM syllabus_models sm
JOIN course_syllabus cs ON cs.id = sm.syllabus_id
JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id;

-- Migrate titles
INSERT INTO syllabus_titles_normalized (module_id, title_name, hours, display_order)
SELECT 
    smn.id as module_id,
    st.title_name,
    st.hours,
    st.position as display_order
FROM syllabus_titles st
JOIN syllabus_models sm ON sm.id = st.model_id
JOIN syllabus_modules_normalized smn ON smn.module_name = sm.model_name 
    AND smn.syllabus_id = (
        SELECT csn.id 
        FROM course_syllabus cs 
        JOIN course_syllabus_normalized csn ON csn.course_id = cs.course_id 
        WHERE cs.id = sm.syllabus_id
    );

-- Migrate topics
INSERT INTO syllabus_topics_normalized (title_id, topic_text, display_order)
SELECT 
    stn.id as title_id,
    stop.topic as topic_text,
    stop.position as display_order
FROM syllabus_topics stop
JOIN syllabus_titles st ON st.id = stop.title_id
JOIN syllabus_titles_normalized stn ON stn.title_name = st.title_name 
    AND stn.module_id = (
        SELECT smn.id 
        FROM syllabus_models sm 
        JOIN syllabus_modules_normalized smn ON smn.module_name = sm.model_name 
        WHERE sm.id = st.model_id
    );
```

#### I. Migrate Curriculum Logs (JSON diff → Field-Level Changes)

```sql
-- Create normalized logs first
INSERT INTO curriculum_logs_normalized (curriculum_id, action, entity_type, entity_id, description, changed_by, created_at)
SELECT 
    curriculum_id,
    CASE 
        WHEN action LIKE '%Create%' THEN 'CREATE'
        WHEN action LIKE '%Update%' THEN 'UPDATE'
        WHEN action LIKE '%Delete%' THEN 'DELETE'
        ELSE 'OTHER'
    END as action,
    CASE 
        WHEN description LIKE '%regulation%' THEN 'Regulation'
        WHEN description LIKE '%semester%' THEN 'Semester'
        WHEN description LIKE '%course%' THEN 'Course'
        WHEN description LIKE '%syllabus%' THEN 'Syllabus'
        ELSE 'Other'
    END as entity_type,
    NULL as entity_id,
    description,
    changed_by,
    created_at
FROM curriculum_logs;

-- Parse diff JSON and create field-level changes
-- Note: This requires custom logic based on your diff structure
-- Example for simple key-value diffs:
INSERT INTO curriculum_log_changes (log_id, field_name, old_value, new_value)
SELECT 
    cln.id as log_id,
    diff_key as field_name,
    JSON_EXTRACT(cl.diff, CONCAT('$.', diff_key, '.old')) as old_value,
    JSON_EXTRACT(cl.diff, CONCAT('$.', diff_key, '.new')) as new_value
FROM curriculum_logs cl
JOIN curriculum_logs_normalized cln ON cln.description = cl.description 
    AND cln.created_at = cl.created_at
CROSS JOIN JSON_TABLE(
    COALESCE(cl.diff, JSON_OBJECT()),
    '$.*' COLUMNS(
        diff_key VARCHAR(100) PATH '$'
    )
) AS jt
WHERE cl.diff IS NOT NULL;
```

### Phase 3: Application Layer Updates

#### Update Go Models

Create new normalized models in `server/models/normalized/`:

```go
// syllabus_normalized.go
package normalized

type CourseSyllabusNormalized struct {
    ID                     uint   `json:"id"`
    CourseID               uint   `json:"course_id"`
    TeamworkTotalHours     uint8  `json:"teamwork_total_hours"`
    SelfLearningTotalHours uint8  `json:"self_learning_total_hours"`
    CreatedAt              string `json:"created_at"`
    UpdatedAt              string `json:"updated_at"`
}

type CourseObjective struct {
    ID            uint   `json:"id"`
    SyllabusID    uint   `json:"syllabus_id"`
    ObjectiveText string `json:"objective_text"`
    DisplayOrder  uint16 `json:"display_order"`
    CreatedAt     string `json:"created_at"`
}

type CourseOutcome struct {
    ID           uint   `json:"id"`
    SyllabusID   uint   `json:"syllabus_id"`
    OutcomeCode  string `json:"outcome_code"`
    OutcomeText  string `json:"outcome_text"`
    DisplayOrder uint16 `json:"display_order"`
    CreatedAt    string `json:"created_at"`
}

type CourseTextbook struct {
    ID           uint   `json:"id"`
    SyllabusID   uint   `json:"syllabus_id"`
    Title        string `json:"title"`
    Authors      string `json:"authors"`
    Publisher    string `json:"publisher,omitempty"`
    Edition      string `json:"edition,omitempty"`
    Year         uint16 `json:"year,omitempty"`
    ISBN         string `json:"isbn,omitempty"`
    DisplayOrder uint16 `json:"display_order"`
    CreatedAt    string `json:"created_at"`
}

type TeamworkActivity struct {
    ID           uint   `json:"id"`
    SyllabusID   uint   `json:"syllabus_id"`
    ActivityName string `json:"activity_name"`
    DisplayOrder uint16 `json:"display_order"`
    CreatedAt    string `json:"created_at"`
    UpdatedAt    string `json:"updated_at"`
}

type SelfLearningMainTopic struct {
    ID           uint   `json:"id"`
    SyllabusID   uint   `json:"syllabus_id"`
    MainTopic    string `json:"main_topic"`
    DisplayOrder uint16 `json:"display_order"`
    CreatedAt    string `json:"created_at"`
    UpdatedAt    string `json:"updated_at"`
}

type SelfLearningResource struct {
    ID           uint   `json:"id"`
    MainTopicID  uint   `json:"main_topic_id"`
    ResourceText string `json:"resource_text"`
    ResourceType string `json:"resource_type"` // Text, Link, Document, Video
    DisplayOrder uint16 `json:"display_order"`
    CreatedAt    string `json:"created_at"`
}
```

#### Update Handlers

Create new handlers in `server/handlers/normalized/`:

```go
// syllabus_normalized_handlers.go
package normalized

import (
    "database/sql"
    "encoding/json"
    "net/http"
    "server/db"
    "server/models/normalized"
    "strconv"
    
    "github.com/gorilla/mux"
)

// GetCourseSyllabusNormalized returns complete normalized syllabus
func GetCourseSyllabusNormalized(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    vars := mux.Vars(r)
    courseID, _ := strconv.Atoi(vars["courseId"])
    
    // Fetch header
    var syllabus normalized.CourseSyllabusNormalized
    err := db.DB.QueryRow(`
        SELECT id, course_id, teamwork_total_hours, self_learning_total_hours, 
               created_at, updated_at
        FROM course_syllabus_normalized
        WHERE course_id = ?
    `, courseID).Scan(&syllabus.ID, &syllabus.CourseID, 
        &syllabus.TeamworkTotalHours, &syllabus.SelfLearningTotalHours,
        &syllabus.CreatedAt, &syllabus.UpdatedAt)
    
    if err == sql.ErrNoRows {
        // Return empty structure
        json.NewEncoder(w).Encode(map[string]interface{}{
            "syllabus_id": nil,
            "objectives": []normalized.CourseObjective{},
            "outcomes": []normalized.CourseOutcome{},
            // ... other fields
        })
        return
    }
    
    // Fetch objectives
    objectives := []normalized.CourseObjective{}
    rows, _ := db.DB.Query(`
        SELECT id, syllabus_id, objective_text, display_order, created_at
        FROM course_objectives
        WHERE syllabus_id = ?
        ORDER BY display_order
    `, syllabus.ID)
    defer rows.Close()
    
    for rows.Next() {
        var obj normalized.CourseObjective
        rows.Scan(&obj.ID, &obj.SyllabusID, &obj.ObjectiveText, 
            &obj.DisplayOrder, &obj.CreatedAt)
        objectives = append(objectives, obj)
    }
    
    // ... fetch other components similarly
    
    response := map[string]interface{}{
        "syllabus":    syllabus,
        "objectives":  objectives,
        // ... other fields
    }
    
    json.NewEncoder(w).Encode(response)
}
```

### Phase 4: Cutover & Validation

1. **Run Migration Scripts** (in test environment first)
2. **Validate Data Integrity**:
   ```sql
   -- Check row counts match
   SELECT 
       (SELECT COUNT(*) FROM course_objectives) as objectives_count,
       (SELECT SUM(JSON_LENGTH(objectives)) FROM course_syllabus WHERE objectives IS NOT NULL) as json_objectives_count;
   ```

3. **Update Application Routes** to use normalized handlers
4. **Deploy Application** with dual-read capability (read from both old and new schema)
5. **Monitor Performance** and validate queries
6. **Switch Write Operations** to normalized schema
7. **Drop Old JSON Columns**:
   ```sql
   ALTER TABLE course_syllabus DROP COLUMN objectives;
   ALTER TABLE course_syllabus DROP COLUMN outcomes;
   -- ... etc
   ```

8. **Rename Normalized Tables** to production names:
   ```sql
   RENAME TABLE course_syllabus TO course_syllabus_old;
   RENAME TABLE course_syllabus_normalized TO course_syllabus;
   -- ... etc
   ```

### Phase 5: Cleanup

```sql
-- Drop old tables after verification period
DROP TABLE IF EXISTS course_syllabus_old;
DROP TABLE IF EXISTS curriculum_logs_old;
-- ... etc
```

## Benefits of Normalized Schema

1. **Query Performance**: Direct column access vs JSON parsing
2. **Data Integrity**: Foreign key constraints prevent orphaned data
3. **Indexing**: Full index support on all fields
4. **Constraints**: CHECK constraints enforce business rules at database level
5. **Concurrency**: Row-level locking works properly (JSON blob locks entire column)
6. **Analytics**: Simple JOINs instead of complex JSON extraction
7. **Maintenance**: Schema changes via ALTER TABLE instead of application logic
8. **Validation**: Database enforces data types and constraints
9. **Backup/Restore**: Standard SQL dump/restore (JSON can have encoding issues)
10. **Compliance**: Meets 3NF requirements for enterprise audits

## Rollback Plan

If issues arise:
1. Keep old JSON columns intact during migration
2. Maintain dual-write mode (write to both schemas)
3. Application can fallback to JSON-based handlers
4. Revert route changes to point back to old handlers

## Testing Checklist

- [ ] All JSON arrays migrated to individual rows
- [ ] Foreign key relationships validated
- [ ] Display order preserved correctly
- [ ] No orphaned records
- [ ] Unique constraints prevent duplicates
- [ ] CHECK constraints enforce business rules
- [ ] Indexes created on foreign keys
- [ ] Application queries return same data
- [ ] Performance benchmarks meet requirements
- [ ] Concurrent write tests pass
- [ ] Backup/restore procedures validated

## Support

For issues during migration:
1. Check migration logs for SQL errors
2. Validate data with count queries
3. Review foreign key violations
4. Test with sample dataset first
5. Document any custom parsing logic needed

This migration eliminates all JSON fields and provides a production-ready, fully normalized database schema.
